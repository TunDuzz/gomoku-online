@model GomokuOnline.Models.Entities.Game
@using GomokuOnline.Models.Entities
@{
    ViewData["Title"] = $"Game - {Model.GameRoom?.Name}";
}

<div class="container-fluid mt-3">
    <div class="row">
        <!-- Game Board -->
        <div class="col-lg-8">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">
                            <i class="fas fa-chess-board me-2"></i>
                            @Model.GameRoom?.Name
                        </h5>
                        <div>
                            @switch (Model.Status)
                            {
                                case GameStatus.InProgress:
                                    <span class="badge bg-success">Đang chơi</span>
                                    break;
                                case GameStatus.Completed:
                                    <span class="badge bg-warning">Hoàn thành</span>
                                    break;
                                case GameStatus.Draw:
                                    <span class="badge bg-secondary">Hòa</span>
                                    break;
                                default:
                                    <span class="badge bg-info">@Model.Status</span>
                                    break;
                            }
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <!-- Game Info -->
                    <div class="row text-center mb-3">
                        <div class="col-3">
                            <h6 class="text-primary">@Model.BoardSize</h6>
                                <small class="text-muted">Bàn cờ</small>
                        </div>
                        <div class="col-3">
                            <h6 class="text-success">@Model.WinCondition</h6>
                                <small class="text-muted">Thắng</small>
                        </div>
                        <div class="col-3">
                            <h6 class="text-info">@Model.TotalMoves</h6>
                            <small class="text-muted">Nước đi</small>
                        </div>
                        <div class="col-3">
                            <h6 class="text-warning" id="turnIndicator">
                                    @if (User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value == Model.CurrentTurnUserId?.ToString())
                                    {
                                        <span>Lượt của bạn</span>
                                    }
                                    else
                                    {
                                        <span>Lượt đối thủ</span>
                                    }
                            </h6>
                            <small class="text-muted">Trạng thái</small>
                        </div>
                    </div>

                    <!-- Game Board -->
                    <div class="text-center">
                        <div id="gameBoard" class="game-board mx-auto" 
                             data-board-size="@Model.BoardSize" 
                             data-win-condition="@Model.WinCondition"
                             data-game-id="@Model.Id">
                        </div>
                    </div>

                    <!-- Game Controls -->
                        @if (Model.Status == GameStatus.InProgress)
                        {
                        <div class="text-center mt-3">
                            <button type="button" class="btn btn-outline-warning me-2" onclick="surrender()">
                                <i class="fas fa-flag me-1"></i>Đầu hàng
                                </button>
                                <button type="button" class="btn btn-outline-info" onclick="requestDraw()">
                                <i class="fas fa-handshake me-1"></i>Xin hòa
                                </button>
                            </div>
                        }
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="col-lg-4">
            <!-- Players -->
            <div class="card mb-3">
                <div class="card-header bg-info text-white">
                    <h6 class="mb-0">
                        <i class="fas fa-users me-2"></i>Người chơi
                    </h6>
                </div>
                <div class="card-body p-2" id="playersContainer">
                    @{
                        var players = Model.GameRoom?.Participants.Where(p => p.Type == ParticipantType.Player).ToList() ?? new List<GameParticipant>();
                    }
                    
                    @foreach (var player in players.OrderBy(p => p.PlayerOrder))
                    {
                        <div class="player-item mb-2 p-2 border rounded @(player.UserId == Model.CurrentTurnUserId ? "border-primary bg-light" : "")" data-player-id="@player.UserId">
                            <div class="d-flex align-items-center">
                                <div class="me-2">
                                    <i class="fas fa-user-circle @(player.PlayerColor == "X" ? "text-primary" : "text-danger")"></i>
                                </div>
                                <div class="flex-grow-1">
                                    <div class="fw-bold">@player.User.Username</div>
                                    <div class="d-flex justify-content-between">
                                        <span class="badge @(player.PlayerColor == "X" ? "bg-primary" : "bg-danger")">
                                            @player.PlayerColor
                                        </span>
                                        @if (player.UserId == Model.CurrentTurnUserId && Model.Status == GameStatus.InProgress)
                                        {
                                            <span class="badge bg-warning text-dark">
                                                <i class="fas fa-clock me-1"></i>Lượt
                                            </span>
                                        }
                                    </div>
                                </div>
                            </div>
                        </div>
                    }
                </div>
            </div>

            <!-- Chat -->
            <div class="card mb-3">
                <div class="card-header bg-success text-white">
                    <h6 class="mb-0">
                        <i class="fas fa-comments me-2"></i>Trò chuyện
                    </h6>
                </div>
                <div class="card-body p-0 d-flex flex-column" style="height: 260px;">
                    <div id="chatMessages" class="p-2 flex-grow-1 overflow-auto" style="background:#f8f9fa;"></div>
                    <div class="p-2 border-top d-flex gap-2">
                        <input id="chatInput" class="form-control" type="text" placeholder="Nhập tin nhắn..." maxlength="500" />
                        <button id="chatSend" class="btn btn-success" type="button" onclick="sendChat()">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                    </div>
                </div>
            </div>

            <!-- Move History -->
            <div class="card">
                <div class="card-header bg-secondary text-white">
                    <h6 class="mb-0">
                        <i class="fas fa-history me-2"></i>Lịch sử nước đi
                    </h6>
                </div>
                <div class="card-body p-0">
                    <div id="moveHistory" class="move-history p-2" style="height: 200px; overflow-y: auto;">
                        @if (Model.Moves.Any())
                        {
                            @foreach (var move in Model.Moves.OrderBy(m => m.MoveNumber).Take(10))
                            {
                                <div class="move-item p-1 border-bottom">
                                    <div class="d-flex justify-content-between">
                                        <div>
                                            <small class="fw-bold">@move.User.Username</small><br>
                                            <small class="text-muted">(@move.Row, @move.Column) - @move.Symbol</small>
                                        </div>
                                        <small class="text-muted">@move.CreatedAt.ToString("HH:mm")</small>
                                    </div>
                                </div>
                            }
                        }
                        else
                        {
                            <p class="text-muted text-center">Chưa có nước đi</p>
                        }
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script>
        // Global variables
        const CURRENT_USER_ID = @(User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? "0");
        let CURRENT_TURN_USER_ID = @(Model.CurrentTurnUserId ?? 0);
        const boardSize = @Model.BoardSize;
        const gameId = @Model.Id;
        let gameBoard = [];
        let isMyTurn = CURRENT_USER_ID === CURRENT_TURN_USER_ID;
        let lastMoveCount = @Model.Moves.Count;
        let gameStatus = '@Model.Status';
        let updateInterval;
        let gameConnection;

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeBoard();
            loadMoves();
            updateBoardInteraction(); // Set initial board state
            initializeSignalR();
            startRealTimeUpdates();
            loadChatHistory();

            // Gửi chat bằng phím Enter
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        sendChat();
                    }
                });
            }
        });
        
        // Initialize SignalR
        async function initializeSignalR() {
            try {
                gameConnection = new signalR.HubConnectionBuilder()
                    .withUrl("/gameHub")
                    .withAutomaticReconnect()
                    .build();
                
                // Join game group
                await gameConnection.start();
                await gameConnection.invoke("JoinGame", gameId);
                
                // Listen for move events
                gameConnection.on("MoveMade", (data) => {
                    handleMoveMade(data);
                });
                
                gameConnection.on("GameEnded", (data) => {
                    handleGameEnded(data);
                });

                // Chat events
                gameConnection.on("MessageReceived", (msg) => {
                    if (msg.gameId !== gameId) return;
                    appendChatMessage(msg.userId, msg.message, msg.timestamp, msg.username);
                });
                
                gameConnection.on("Error", (message) => {
                    console.error("SignalR Error:", message);
                });
            } catch (err) {
                console.error("SignalR connection failed:", err);
            }
        }

        // Send chat
        async function sendChat() {
            const input = document.getElementById('chatInput');
            const text = (input?.value || '').trim();
            if (!text) return;
            try {
                if (gameConnection && gameConnection.state === signalR.HubConnectionState.Connected) {
                    await gameConnection.invoke('SendMessage', gameId, text);
                    input.value = '';
                }
            } catch (e) {
                console.error('Send chat failed', e);
            }
        }

        // Render chat message
        function appendChatMessage(userId, message, timestamp, username = null) {
            const box = document.getElementById('chatMessages');
            if (!box) return;
            const isMine = String(userId) === String(CURRENT_USER_ID);
            const item = document.createElement('div');
            item.className = `chat-item p-1 ${isMine ? 'text-end' : ''}`;
            const time = new Date(timestamp).toLocaleTimeString();
            item.innerHTML = `
                <small class="${isMine ? 'text-primary' : 'text-dark'}">
                    <span class="fw-bold">${isMine ? 'Bạn' : (username || 'Đối thủ')}</span> · ${time}
                </small>
                <div class="px-2 py-1 mt-1 rounded ${isMine ? 'bg-primary text-white' : 'bg-white border'}" style="display:inline-block; max-width: 90%; word-break: break-word;">
                    ${escapeHtml(message)}
                </div>
            `;
            box.appendChild(item);
            box.scrollTop = box.scrollHeight;
        }

        function escapeHtml(s) {
            return s.replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
        }

        async function loadChatHistory() {
            try {
                const res = await fetch(`/Game/GetChatMessages?gameId=${gameId}&take=50`);
                const data = await res.json();
                if (data.success) {
                    const list = data.messages || [];
                    list.forEach(m => appendChatMessage(m.userId, m.message, m.timestamp, m.username));
                }
            } catch (e) {
                console.error('Load chat history failed', e);
            }
        }
        
        // Handle move made event
        function handleMoveMade(data) {
            if (data.gameId === gameId) {
                // Update board
                gameBoard[data.row][data.column] = data.symbol;
                const cell = document.querySelector(`[data-row="${data.row}"][data-col="${data.column}"]`);
                if (cell) {
                    cell.textContent = data.symbol;
                    cell.className = `board-cell ${data.symbol === 'X' ? 'player-x' : 'player-o'}`;
                }
                
                // Update turn
                CURRENT_TURN_USER_ID = data.currentTurnUserId;
                isMyTurn = CURRENT_USER_ID === CURRENT_TURN_USER_ID;
                
            updateTurnIndicator();
                updatePlayersTurn(CURRENT_TURN_USER_ID);
                
                // Update total moves
                lastMoveCount++;
                updateTotalMoves(lastMoveCount);
                
                // Add to move history
                addMoveToHistory(data.row, data.column, data.symbol);
                
                // Enable/disable board based on turn
                updateBoardInteraction();
                
                // Check if game ended
                if (data.isWin || data.gameStatus === 'Completed' || data.gameStatus === 'Draw') {
                    gameStatus = data.gameStatus;
                    clearInterval(updateInterval);
                    setTimeout(() => {
                        if (data.isWin) {
                            alert('Game kết thúc!');
                        } else if (data.gameStatus === 'Draw') {
                            alert('Game hòa!');
                        }
                        location.reload();
                    }, 500);
                }
            }
        }
        
        // Handle game ended event
        function handleGameEnded(data) {
            if (data.gameId === gameId) {
                gameStatus = data.status;
                clearInterval(updateInterval);
                setTimeout(() => {
                    alert('Game kết thúc!');
                    location.reload();
                }, 500);
            }
        }

        // Start real-time updates
        function startRealTimeUpdates() {
            // Update every 2 seconds
            updateInterval = setInterval(updateGameState, 2000);
            
            // Also update when window becomes visible
            document.addEventListener('visibilitychange', function() {
                if (!document.hidden) {
                    updateGameState();
                }
            });
        }

        // Update game state from server
        async function updateGameState() {
            try {
                const response = await fetch(`/Game/GetGameState/${gameId}`);
                const data = await response.json();
                
                if (data.success) {
                    const gameData = data.game;
                    
                    // Check if game status changed
                    if (gameData.status !== gameStatus) {
                        gameStatus = gameData.status;
                        if (gameStatus === 'Completed' || gameStatus === 'Draw') {
                            clearInterval(updateInterval);
                            setTimeout(() => {
                                alert(gameStatus === 'Completed' ? 'Game kết thúc!' : 'Game hòa!');
                                location.reload();
                            }, 500);
                            return;
                        }
                    }
                    
                    // Check if new moves were made
                    if (gameData.totalMoves > lastMoveCount) {
                        lastMoveCount = gameData.totalMoves;
                        await loadLatestMoves();
                    }
                    
                    // Update turn indicator
                    if (gameData.currentTurnUserId !== CURRENT_TURN_USER_ID) {
                        CURRENT_TURN_USER_ID = gameData.currentTurnUserId;
                        isMyTurn = CURRENT_USER_ID === CURRENT_TURN_USER_ID;
                        
                        updateTurnIndicator();
                        updatePlayersTurn(CURRENT_TURN_USER_ID);
                        updateBoardInteraction(); // Update board interaction when turn changes
                    }
                    
                    // Update total moves display
                    updateTotalMoves(gameData.totalMoves);
                }
            } catch (error) {
                console.error('Error updating game state:', error);
            }
        }

        // Load latest moves
        async function loadLatestMoves() {
            try {
                const response = await fetch(`/Game/GetLatestMoves/${gameId}?lastMoveCount=${lastMoveCount}`);
                const data = await response.json();
                
                if (data.success && data.moves.length > 0) {
                    data.moves.forEach(move => {
                        // Update board
                        gameBoard[move.row][move.col] = move.symbol;
                        const cell = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                        if (cell) {
                            cell.textContent = move.symbol;
                            cell.className = `board-cell ${move.symbol === 'X' ? 'player-x' : 'player-o'}`;
                        }
                        
                        // Add to move history
                        addMoveToHistory(move.row, move.col, move.symbol, move.username);
                    });
                }
            } catch (error) {
                console.error('Error loading latest moves:', error);
            }
        }

        // Update total moves display
        function updateTotalMoves(totalMoves) {
            const totalMovesElement = document.querySelector('.col-3 .text-info');
            if (totalMovesElement) {
                totalMovesElement.textContent = totalMoves;
            }
        }

        // Initialize the game board
        function initializeBoard() {
            const boardContainer = document.getElementById('gameBoard');
            if (!boardContainer) return;

            // Clear existing content
            boardContainer.innerHTML = '';

            // Set grid style
            const cellSize = window.innerWidth <= 768 ? 35 : 45;
            boardContainer.style.gridTemplateColumns = `repeat(${boardSize}, ${cellSize}px)`;
            boardContainer.style.gridTemplateRows = `repeat(${boardSize}, ${cellSize}px)`;

            // Create board cells
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    gameBoard[i] = gameBoard[i] || [];
                    gameBoard[i][j] = '';
                    
                    const cell = document.createElement('div');
                    cell.className = 'board-cell';
                    cell.setAttribute('data-row', i);
                    cell.setAttribute('data-col', j);
                    cell.onclick = () => makeMove(i, j);
                    boardContainer.appendChild(cell);
                }
            }
        }

        // Load existing moves
        function loadMoves() {
            const moves = [
                @foreach (var move in Model.Moves.OrderBy(m => m.MoveNumber))
                {
                    <text>
                    {
                        row: @move.Row,
                        col: @move.Column,
                        symbol: '@move.Symbol',
                        userId: @move.UserId
                    },
                    </text>
                }
            ];

            moves.forEach(move => {
                gameBoard[move.row][move.col] = move.symbol;
                const cell = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                if (cell) {
                    cell.textContent = move.symbol;
                    cell.className = `board-cell ${move.symbol === 'X' ? 'player-x' : 'player-o'}`;
                }
            });
        }

        // Make a move
        async function makeMove(row, col) {
            if (!isMyTurn) {
                alert('Chưa đến lượt của bạn!');
                return;
            }
            
            if (gameBoard[row][col] !== '') {
                alert('Ô này đã có quân cờ!');
                return;
            }

            // Disable board temporarily during move
            const boardContainer = document.getElementById('gameBoard');
            boardContainer.style.pointerEvents = 'none';

            try {
                // Send move via SignalR
                if (gameConnection && gameConnection.state === signalR.HubConnectionState.Connected) {
                    await gameConnection.invoke("MakeMove", gameId, row, col);
            } else {
                    // Fallback to HTTP if SignalR not connected
                    const response = await fetch('/Game/MakeMove', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: `gameId=${gameId}&row=${row}&column=${col}`
                    });
                    
                    const data = await response.json();
                    
                    if (!data.success) {
                        alert(data.message || 'Có lỗi xảy ra!');
                        // Re-enable board if move failed
                        updateBoardInteraction();
                    }
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Có lỗi xảy ra khi thực hiện nước đi!');
                // Re-enable board if error occurred
                updateBoardInteraction();
            }
        }

        // Update turn indicator
        function updateTurnIndicator() {
            const turnIndicator = document.getElementById('turnIndicator');
            if (turnIndicator) {
                turnIndicator.textContent = isMyTurn ? 'Lượt của bạn' : 'Lượt đối thủ';
                turnIndicator.className = isMyTurn ? 'text-success' : 'text-warning';
            }
        }

        // Update players turn
        function updatePlayersTurn(currentTurnUserId) {
            const playersContainer = document.getElementById('playersContainer');
            if (!playersContainer) {
                return;
            }

            // Remove all turn badges and highlighting
            const playerItems = playersContainer.querySelectorAll('.player-item');
            
            playerItems.forEach(item => {
                item.classList.remove('border-primary', 'bg-light');
                const turnBadge = item.querySelector('.badge.bg-warning');
                if (turnBadge) {
                    turnBadge.remove();
                }
            });

            // Add turn badge and highlighting to current player
            const currentPlayerItem = playersContainer.querySelector(`[data-player-id="${currentTurnUserId}"]`);
            if (currentPlayerItem) {
                currentPlayerItem.classList.add('border-primary', 'bg-light');
                
                const badgeContainer = currentPlayerItem.querySelector('.d-flex.justify-content-between');
                if (badgeContainer) {
                    const turnBadge = document.createElement('span');
                    turnBadge.className = 'badge bg-warning text-dark';
                    turnBadge.innerHTML = '<i class="fas fa-clock me-1"></i>Lượt';
                    badgeContainer.appendChild(turnBadge);
                }
            }
        }

        // Update board interaction based on turn
        function updateBoardInteraction() {
            const boardContainer = document.getElementById('gameBoard');
            if (!boardContainer) return;
            
            if (isMyTurn && gameStatus === 'InProgress') {
                // Enable board for current player
                boardContainer.style.pointerEvents = 'auto';
                boardContainer.style.opacity = '1';
                
                // Add visual feedback
                const cells = boardContainer.querySelectorAll('.board-cell');
                cells.forEach(cell => {
                    if (cell.textContent === '') {
                        cell.style.cursor = 'pointer';
                        cell.style.backgroundColor = '#f8f9fa';
                    }
                });
            } else {
                // Disable board for other players
                boardContainer.style.pointerEvents = 'none';
                boardContainer.style.opacity = '0.7';
                
                // Remove visual feedback
                const cells = boardContainer.querySelectorAll('.board-cell');
                cells.forEach(cell => {
                    if (cell.textContent === '') {
                        cell.style.cursor = 'not-allowed';
                        cell.style.backgroundColor = '#e9ecef';
                    }
                });
            }
        }

        // Add move to history
        function addMoveToHistory(row, col, symbol, username = null) {
            const moveHistory = document.getElementById('moveHistory');
            if (!moveHistory) return;

            const moveItem = document.createElement('div');
            moveItem.className = 'move-item p-1 border-bottom';
            moveItem.innerHTML = `
                <div class="d-flex justify-content-between">
                    <div>
                        <small class="fw-bold">${username || (symbol === 'X' ? 'Người chơi X' : 'Người chơi O')}</small><br>
                            <small class="text-muted">(${row}, ${col}) - ${symbol}</small>
                    </div>
                    <small class="text-muted">${new Date().toLocaleTimeString()}</small>
                </div>
            `;

            moveHistory.appendChild(moveItem);
            moveHistory.scrollTop = moveHistory.scrollHeight;
        }

        // Game control functions
        function surrender() {
            if (confirm('Bạn có chắc muốn đầu hàng?')) {
                // Implement surrender logic
                alert('Chức năng đang phát triển');
            }
        }

        function requestDraw() {
            if (confirm('Bạn có muốn xin hòa?')) {
                // Implement draw request logic
                alert('Chức năng đang phát triển');
            }
        }

        // Cleanup when page unloads
        window.addEventListener('beforeunload', function() {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
        });
    </script>
}

<style>
    .game-board {
        display: grid;
        gap: 2px;
        background-color: #333;
        padding: 10px;
        border-radius: 8px;
        border: 3px solid #333;
        width: fit-content;
        margin: 0 auto;
    }

    .board-cell {
        width: 45px;
        height: 45px;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s ease;
        user-select: none;
    }

    .board-cell:hover {
        background-color: #e9ecef;
        transform: scale(1.05);
    }

    .board-cell.player-x {
        color: #007bff;
        background-color: #e3f2fd;
    }

    .board-cell.player-o {
        color: #dc3545;
        background-color: #ffebee;
    }

    .player-item {
        transition: all 0.3s ease;
    }

    .move-history {
        background-color: #f8f9fa;
    }

    .move-item {
        background-color: white;
        transition: background-color 0.2s ease;
    }

    .move-item:hover {
        background-color: #f8f9fa;
    }

    @@media (max-width: 768px) {
        .board-cell {
            width: 35px;
            height: 35px;
            font-size: 16px;
        }
    }
</style>
